# Stack for x86 (32-bit) Intel microprocessor architecture

### Table of Contents  

- [Overview](#overview)
- [Source code of victim.c](#source-code-of-victimc)
- [Dissassembly of victim.exe by IDA Freeware/Pro](#dissassembly-of-victimexe-by-ida-freeware-pro)
- [Dissassembly of victim.exe by Immunity Debugger](#dissassembly-of-victimexe-by-immunity-debugger)
- [Video demo](#video-demo)
- [Debugging victim.exe with Immunity Debugger](#debugging-victimexe-with-immunity-debugger)
  * [1. At the first instruction of victim.exe](#1-at-the-first-instruction-of-victimexe)
  * [2. At the first instruction of main(.)](#2-at-the-first-instruction-of-main--)
  * [3. After the prologue of main(.) is done](#3-after-the-prologue-of-main---is-done)
  * [4. Right before calling f(.)](#4-right-before-calling-f--)
  * [5. After calling f(.) and at the first instruction of f(.)](#5-after-calling-f---and-at-the-first-instruction-of-f--)
  * [6. After the prologue of f(.)](#6-after-the-prologue-of-f--)
  * [7. Right before calling strcpy(.)](#7-right-before-calling-strcpy--)
  * [8. Right after calling strcpy(.)](#8-right-after-calling-strcpy--)
  * [9. Right before returning from f(.)](#9-right-before-returning-from-f--)
  * [10. Right after returning from f(.) to main(.)](#10-right-after-returning-from-f---to-main--)

### Overview 
We will explain how the stack is used, particularly when a function is called. The figure below shows an example memory layout of a program under the flat memory model. The stack is a piece of memory used by a program storing arguments to a function, local variables and other data such as return address of a function. The top of the stack is referred to by the stack register ESP. That is, ESP contains an address (e.g. of 4 bytes), which is the address of the stack top. For simplicity, when we mention a register, we refer to the value stored in the register. In C language, we often do not work on the stack directly. The compiler compiles the C code and generates the assembly code (binary code too) manipulating the stack. In assembly language, we have to write the instructions performing the operation on the stack. 

```
+-------------------+  <-- HIGHER ADDRESS
|                   |
|   Stack           |  <-- Stack top pointed to by ESP (push decreases ESP; pop increases ESP)
|                   |
+-------------------+  <-- LOWER ADDRESS
|                   |
|   Heap            |  <-- malloc(.) allocates memory on heap 
|                   |
+-------------------+
|                   |
| code and data     |  <-- Data can be global variables and others such as dynamic library info
|                   |
+-------------------+  
```

Here are some example assembly instructions working on the stack.
* *push eax* pushes the value of a gernal register EAX onto the stack top and decreases esp by 4. That is, the stack grows down to lower address when we push data onto the stack. 
* *pop ebx* pops the data at the top of the stack into a gernal register EBX and increases esp by 4. 
* *call f* calls the function f, pushing the return address of function f onto the stack, decreasing ESP by 4, and updating EIP with the address of f so that CPU will run f after *call f* is done. 
* *ret* is used at the end of a function. It pops the data (often return address) at the stack top into EIP and increases ESP by 4. Therefore, after *ret* is done, CPU runs the instruction at the function's return address.
* ESP can also be manipulated by arithmatic operations. 

The figure below shows the stack frame of a function in general. Please note some elements may miss depending on the actual code. For example, if there is no local variable, there will be no local variables allocated on the stack. If the function has no arguments, there will be no function arguments on the stack either.
```
        +------------------------------+ <-- Higher address
        | function arguments           |
        +------------------------------+
        | return address               |
        +------------------------------+
        | saved registers (e.g. ebp)   |
EBP --> +------------------------------+  
        | local variables              |
ESP --> +------------------------------+  <-- Lower address
```

### Source code of victim.c 
```
1. // victim.c 
2. // gcc -o victim.exe victim.c
3. #include <stdio.h>
4. #include <string.h>

5. void f(char *str) {
6.   char foo[8];
7.   strcpy(foo, str);
8. }

9. void main(int argc, char **argv) {  
10.   f(argv[1]);
11.   return;
12. }
```

### Dissassembly of victim.exe by IDA Freeware/Pro
```
.text:004015C0 ; =============== S U B R O U T I N E =======================================
.text:004015C0
.text:004015C0 ; Attributes: bp-based frame
.text:004015C0
.text:004015C0 ; int __cdecl f(char *)
.text:004015C0                 public _f
.text:004015C0 _f              proc near               ; CODE XREF: _main+19↓p
.text:004015C0
.text:004015C0 var_10          = byte ptr -10h
.text:004015C0 arg_0           = dword ptr  8
.text:004015C0
.text:004015C0                 push    ebp
.text:004015C1                 mov     ebp, esp
.text:004015C3                 sub     esp, 28h
.text:004015C6                 mov     eax, [ebp+arg_0]
.text:004015C9                 mov     [esp+4], eax    ; char *
.text:004015CD                 lea     eax, [ebp+var_10]
.text:004015D0                 mov     [esp], eax      ; char *
.text:004015D3                 call    _strcpy
.text:004015D8                 nop
.text:004015D9                 leave
.text:004015DA                 retn
.text:004015DA _f              endp
.text:004015DA
.text:004015DB
.text:004015DB ; =============== S U B R O U T I N E =======================================
.text:004015DB
.text:004015DB ; Attributes: bp-based frame fuzzy-sp
.text:004015DB
.text:004015DB ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:004015DB                 public _main
.text:004015DB _main           proc near               ; CODE XREF: ___tmainCRTStartup+236↑p
.text:004015DB
.text:004015DB argc            = dword ptr  8
.text:004015DB argv            = dword ptr  0Ch
.text:004015DB envp            = dword ptr  10h
.text:004015DB
.text:004015DB                 push    ebp
.text:004015DC                 mov     ebp, esp
.text:004015DE                 and     esp, 0FFFFFFF0h
.text:004015E1                 sub     esp, 10h
.text:004015E4                 call    ___main  ; added by gcc and can be ignored
.text:004015E9                 mov     eax, [ebp+argv]
.text:004015EC                 add     eax, 4
.text:004015EF                 mov     eax, [eax]
.text:004015F1                 mov     [esp], eax      ; char *
.text:004015F4                 call    _f
.text:004015F9                 nop
.text:004015FA                 leave
.text:004015FB                 retn
.text:004015FB _main           endp
```

### Dissassembly of victim.exe by Immunity Debugger

The disassembly by IDA and Immunity Debugger are the same although the expressions are a bit different. In Immunity Debugger, *DWORD PTR* is called a size directive and means the size of the operand is 32 bits. CS (code segment), DS (data segment), SS (stack segment) and ES (extra segment) are segment registers and can be ignored in the flat memory mode used by Windows and Linux. 

![Dissassembly of victim.exe by Immunity Debugger](./Images/ID-Disassembly.PNG?raw=true "Dissassembly of victim.exe by Immunity Debugger")

### Video demo 
Here is a video explaining the use of stack by victim.c.

[![Video demo of stack with victim.c](https://img.youtube.com/vi/GipTMvUtnpY/0.jpg)](https://youtu.be/GipTMvUtnpY)

### Debugging victim.exe with Immunity Debugger

We feed victim.exe with an argument "aaaa". 

Please note the line highlighted in dark blue in the diassembly window is the next instruction to run. We use the register name such as EAX/eax to refer to the value stored in the register.

#### 1. At the first instruction of victim.exe 

The image below shows what happens after victim.exe is loaded into the computer memory and before it runs its first instruction. Immunity Debugger stops at the entry point of victim.exe. The compiler, i.e. gcc in this case, adds quite some code. So the entry point of victim.exe is not main(.) in victim.c. The loader of Windows loads victim.exe in the computer memory and then gives the execution right to victim.exe. 

![At the first instruction of victim.exe](./Images/01-Start.PNG?raw=true "At the first instruction of victim.exe")

#### 2. At the first instruction of main(.)

I set a breackpoint at the first instruction of main(.) at the memory address 004015DB and run the code to over there. Immunity Debugger has not run the instruction at the breakpoint yet and will run it next. You may wonder how I find the code of main(.). I use IDA Freeware, which identifies the code added by a compiler so as to find the user written code. Please pay attention to the change of the stack pointer ESP and instruction pointer EIP, which contains the address of the instruction next to run.

![First instruction of main()](./Images/02-Main-Entry.PNG?raw=true "At the first instruction of main(.)")

#### 3. After the prologue of main(.) is done

The two instructions at 004015DB and 004015DC are the prologue of the function main(.) and set up the stack. 
* *push ebp* stores the value of ebp onto the stack and updates esp to point to the stack top, where ebp is stored right now. Why is ebp saved? ebp is the base stack pointer and is used to refer to a function's arguments and local variables on the stack. We want to save ebp, which is used by the caller of the current function, and do not want to disrupt the caller. 
* *mov ebp, esp* establishes the base stack pointer ebp for main(.). 

*and esp, 0FFFFFFF0h* at 004015DE and *sub esp, 10h* at 004015E1 prepare the stack to call f(.). 
* *and esp, 0FFFFFFF0h* is for memory alignment and has no relationship with the functionality of the code.
* *sub esp, 10h* allocates stack space to save the argument for f(.).

Please ignore the call instruction at 004015E9, which is added by the compiler. Although the stack changes with the call and within f(.), the stack returns to the state before the call after the call is done. So ignoring the call is just fine and will not affect our analysis. 

![After the prologue of main(.) is done](./Images/03-Main-AfterPrologue.PNG?raw=true "After the prologue of main(.) is done")

#### 4. Right before calling f(.)

Instructions at 004015E9, 004015EC and 004015F1 find the address of the user provided argument.
* *mov eax, [ebp+C]* moves the data (4 bytes) stored at ebp+C to eax. The data is a pointer (address), i.e. argv in victim.c (denoted as argv-c), not argv in IDA disassembly. argv in the IDA disassembly is the offset relative to ebp on the stack to find argv-c. A list of other addresses is stored at argv-c. Each such address points to one argument. For exampl, argv[0] of main(.) points to the program name, .
* *add eax, 4* finds the address of argv[1] and puts it into eax. 
* *eax, [eax]* puts argv[1] into eax. argv[1] (i.e., the address of the user provided argument).

* *mov [esp], eax* at 004015F1 puts argv[1] as the argument for f(.) at the stack top.    
* *call _f* pushes return address (004015F9) of f(.) onto the stack, updates esp to point to the stack top (where 004015F9 is saved) and then run the first instruction of f(.).

![Right before calling f()](./Images/04-Main-RightBeforeCallingf.PNG?raw=true "Right before calling f()")

#### 5. After calling f(.) and at the first instruction of f(.)

It can be obserbed that on the stack 0061FEBC, i.e., stack top pointed to by esp, the return address 0061FEBC of f(.) is stored. 

At 0061FEC0 of the stack, just above the return address, is the argument for f(.).

![After calling f(.) and at the first instruction of f(.)](./Images/05-f-FirstInstruction.PNG?raw=true "After calling f(.) and at the first instruction of f(.)")

#### 6. After the prologue of f(.)
The prologue of f(.) stores ebp (used by main().) onto the stack. 

At 004015C3, *sub esp, 28h* allocates space for f(.)'s local buffer foo[8] and also arguments for strcpy(.). 

![After the prologue of f(.)](./Images/06-f-AfterPrologue.PNG?raw=true "After the prologue of f(.)")

#### 7. Right before calling strcpy(.) 

The following four instructions prepare the stack to call strcpy(.).
* At 004015C6, *mov eax, [ebp+8]* copies the data (i.e. argv[1] that is the argment for f(.) ), stored at address ebp+8, to exa.
* At 004015C9, *mov [esp+4], eax* copies argv[1] to the stack at esp+4, which stores the source address argument for strcpy(.).
* At 004015CD, *lea eax, [ebp-10]* copies ebp-0x10, which is the address of the local buffer foo[8], to eax. This instruction implies that foo[8] is located at ebp-0x10.
* At 004015D0, *mov [esp], eax* copies eax to the stack top, which stores the destination address argument for strcpy(.).

![Right before calling strcpy(.)](./Images/07-f-RightBeforeCallingstrcpy.PNG?raw=true "Right before calling strcpy(.)")

#### 8. Right after calling strcpy(.) 
strcpy(.) copies the user provided argument ("aaaa") to ebp-10 on the stack. A quiz: what if the user argument is very long, e.g. 256 bytes?

The image below shows the stack frames for functions f() and main(). At this point of running victim.exe, we can clearly see the local buffer foo[8] of f(.) is filled with "aaaa". If a user provides a longer string of 'a', the string will fill up the buffer toward higher address. If the string is long enough, it may overwrite data stored at higher address.

A keen reader may find argv in this image is different from argv from previous images above. The reason is this image is a screenshot of another running session of victim.exe. Aparently, the operating system may put the arguments to the main(.) function at different addresses in each run.

![Right after calling strcpy(.)](./Images/08-f-RightAfterCallingstrcpy.PNG?raw=true "Right after calling strcpy(.)")

#### 9. Right before returning from f(.) 

* At 004015D9 *leave* is equivanent to two instructions *move esp, ebp* and *pop ebp*. 
* At 004015DA *retn* pops the data, which is actually the return address of f(.) at the stack top into eip and increases esp by 4.

![Right before returning from f(.)](./Images/09-f-RightBeforretn.PNG?raw=true "Right before returning from f(.)")

#### 10. Right after returning from f(.) to main(.)

Since retn pops the return address of f(.) into eip, we come back to run *nop* at 004015F9.
![Right after returning from f(.) to main(.)](./Images/10-main-RightAfterfrretn.PNG?raw=true "Right after returning from f(.) to main(.)")

