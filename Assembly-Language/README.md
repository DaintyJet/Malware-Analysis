# Assembly Language

Please refer to [code examples](#code-examples) if you wonder how assembly language is used in a full program. Note: some examples may come from the Internet with minor changes by me.

## Table of Contents  
* [Introduction](#introduction)
* [Programming environment](#programming-environment)
* [Writing assembly code](#writing-assembly-code)
* [Function and entry point function](#function-and-entry-point-function)
* [Instructions](#instructions)
    - [Pseudo-instructions](#pseudo-instructions)
    - [x86 instructions](#x86-instructions)
* [Heap and stack](#heap-and-stack)
* [Code examples](#code-examples)
    - [exitProcess.asm](#exitprocessasm)
    - [func.asm](#funcasm)
    - [MessageBox.asm](#messageboxasm)
    - [helloworld.asm](#helloworldasm)
    - [helloworld-gl.asm](#helloworld-glasm)
    - [power.asm](#powerasm)
* [References](#references)

## Introduction

There are different types of assembly languages for different computer architectures such as Intel and Arm. Each architecture has its own instruction set. For the same assembly language instruction set, there are different assemblers using different grammars. For the x86 instruction set discussed in this post, two popular assemblers are the Netwide Assembler ([NASM](https://www.nasm.us/)) and Microsoft Macro Assembler reference ([MASM](https://docs.microsoft.com/en-us/cpp/assembler/masm/microsoft-macro-assembler-reference?view=msvc-160)). NASM has a package that emulates part of MASM. So do not confuse yourself with different grammars of NASM and MASM.

Now let's see how we "compile" the assembly code and get an exectuable (file). When we talk about compiling C code, there are really four steps involved in the whole proccess: preprocessing, compiling, assembly, and linking.
1. **Preprocessing**: Preprocessing is the first step. The C preprocessor expands all macros definitions and include statements and passes the result to the compiler.
1. **Compiling**: Compiling is the second step. The C compilor translates the preprocessed C code into assembly code, adding anything such as optimization it wants into the code.
1. **Assembly**: Assembly is the third step of compilation. An assembler translates the assembly code into machine code, creating an object file.
1. **Linking**: Linking is the final step of compilation. The linker links object files and libraries together to create the final executable file.

Apparently, for assembly code, we only need the steps of assembly and linking to create the executable from the assembly code.

Another thing worthy of attention is how an executable uses the computer memory. We focus our discussion on the flat memory model, which is used by Windows and Linux. For the flat memory model, an application/program just treats the whole computer memory as its own, called virtual memory. You may wonder what about other programs running the same time and using the memory? The hardware and operating system translate a virtual memory address to a physical memory address. So you do not need to worry about how the physical memory is shared by multiple programs.

## Programming environment

Here is a Windows environment convenient to learn assembly language. 
* **Editor**: [Notepad++](https://notepad-plus-plus.org/downloads/) is often convenient to edit small assembly code and C program.
* **Assembler**: [nasm](https://www.nasm.us/)
* **Linker**: Either [Mingw-w64](http://mingw-w64.org/doku.php) (i.e. gcc) or [golink](http://www.godevtool.com/) can be used although assembly code shall use different entry point (main(.) function) names and external function names.
  * Mingw-w64 (i.e. gcc) can be used if no Windows APIs are used and standard C libraries are used.
  * golink is more general to link assembly code, which may use either Windows APIs or standard C libraries. 

## Writing assembly code

Writing assembly code is like writing other programming language code. You got to learn the grammar. With the right tutorial, it is not so hard but just as boring as learning other language grammars :smiley: This [Assembly Programming Tutorial](https://www.tutorialspoint.com/assembly_programming/index.htm) is good for NASM. 

Basically like any programming language, we got to define data and function. You put data (global variables actually) into data sections and code into code/text sections, which contain functions. For example

```
section	.data	; declaring initialized data section
```
```
section .bss	; declaring uninitialized data segment
```
```
section .text	; declaring text (code) section
```
";" above refers to comment.

#### func.asm
See a complete assembly program as follows for how sections are declared.
```
; Assembly language comment begins with a semicolon (;)
; ----------------------------------------------------------------------------
; func.asm
; This is a Win32 console program that uses a function to compute an addition sum and prints out the result.
; It needs to be linked with Windows libraries.
;
; Assemble: nasm -f win func.asm
; Link: golink /console func.obj msvcrt.dll kernel32.dll
; ----------------------------------------------------------------------------

; declare entry point. 
; If you do not specify the entry point with the command switch GoLink assumes START will be used 
global start

; extern declares a symbol not defined in the module being assembled, 
; but in some other module and needs to be referred to by this one
; if one module declares a symbol as EXTERN and refers to it, 
; some other module must actually define the symbol and declare it as GLOBAL
extern printf	;from msvcrt. msvcrt.dll is the C standard library for the Visual C++ (MSVC) compile
extern ExitProcess	;from kernel32

section	.data	; declaring data section

; Allocating storage space for initialized data, variable frmt
; From the NASM documentation: The colon after a label is also optional.
frmt:	db '%d',0	; Declare a character string "%d", where 0 is the null terminator

section .text	; declaring text (code) section
func:	; function label
    xor eax, eax	; exclusive or and save into eax. 0 as a result
    mov eax, 10	; move 10 into eax
    add eax, 5	; add 5 into eax
    ret	; return

start:	; entry point
    ; call func. 
    ; It does the following: push return address of func (address of push eax) onto stack; jumps to func
    call func	
	
    push eax	; push eax onto stack. esp+=4
    push frmt	; push frmt (an address) onto stack. esp+=4
    call	printf	; call printf. equivalent printf(frmt, eax)
	
    add	esp, 8	; add 8 into esp, which points to the top of the stack
    push	0	; push 0 onto the stack. 
    call	ExitProcess	; call ExitProcess. Equivalent to ExitProcess(0)
```

For local variables and function arguments, we have to use the stack, which will be discussed later.

## Function and entry point function

To define a function, e.g. func, use the following format
```
func:
   ; func body
   ret ; done with func and return
```
Please refer to [func.asm](#funcasm) above for an example func.

To define a main function (entry point), you got to be careful. If you do not specify the entry point with the command switch, GoLink assumes "start" will be used.
```
global start ; Declare entry point called start
```
Then in the text section, write down your "start" function.

For gcc, the entry point shall be called _main.
```
global  _main ; Declare entry point called _main
```
Then in the text section, write your "_main" function.

To use a function in libraries, use extern to declare the function exists somewhere else not in the current code file.
```
extern  _printf	; _printf(.) is from standard C library
```
```
extern ExitProcess	; ExitProcess(.) is from Windows kernel32.dll
```

#### helloworld.asm
Examples of entry points are given as follows.
```
; Assembly language comment begins with a semicolon (;)
; ----------------------------------------------------------------------------
; helloworld.asm
; This is a gcc command line program that writes "Hello, World" on one line and then exits.
; It needs to be linked with the standard C library.
;
; Assemble: nasm -f win helloworld.asm
; Link: gcc -m32 helloworld.obj -s -o helloworld.exe
; ----------------------------------------------------------------------------

    global  _main	; Declare entry point _main
    extern  _printf	; From standard C library

    section .text	; Declare code/text section
_main:	; _main function
    push    message	; push message (an address) onto stack
    call    _printf	; call _printf (external) function
    add     esp, 4	; esp+=4
    ret
message:	; A label points to a string in the code section!
    db  'Hello, World', 10, 0	; hello world string. 10 is the Line Feed character. 0 is the null terminator
```

For comparision, below is the golink version of the helloworld.asm. Please note the entry point and printf are different from those in the gcc version of the assembly code. The linking command is different too.
```
; Assembly language comment begins with a semicolon (;)
; ----------------------------------------------------------------------------
; helloworld-gl.asm
; Assemble: nasm -f win helloworld-gl.asm
; Link: golink /console helloworld-gl.obj msvcrt.dll
;
; This is a Win32 console program that writes "Hello, World" on one line and
; then exits.  It needs to be linked with MSVCRT. DLL, the C standard library for Visual C++ (MSVC).
; ----------------------------------------------------------------------------

    global  start	; Declare entry point _main
    extern  printf	; from standard C library

    section .text	; Declare code/text section
start:	; Entry point
    push    message	; push message (an address) onto stack
    call    printf	; call _printf (external) function
    add     esp, 4	; esp+=4
    ret
message:	; A label points to a string 
    db  'Hello, World', 10, 0	; hello world string. 10 is the Line Feed character. 0 is the null terminator
```

## Instructions
You got to program and learn each instruction one by one. An instruction has the following format
```
optional-label: opcode operands ;comment 
```
The label is optional and the colon is optional too. Opcodes are operation codes and tell the CPU which operation the program wants to perform. Operands identify the data used by an instruction. There are immediate operand (a constant value or an expression.), register operand (a value in a register) and memory operand (a value stored in memory).

#### Pseudo-instructions 
Pseudo-instructions are not real x86 machine instructions. We can use pseudo-instructions to declare variables/data in the output file.
* DB, DW, DD, DQ, DT, DO, DY and DZ for declaring initialized data
```
frmt:	db '%d',0 ; Allocating storage space for initialized variable frmt. 0 is the null terminator
```
* RESB, RESW, RESD, RESQ, REST, RESO, RESY and RESZ for declaring initalized data
```
name:	resb 100	; allocate 100 bytes
```
* EQU for defining constants
```
NULL equ 0 ; NULL is (means) 0
```
Refer to Reference [2] for the nasm doc and things specific in nasm.

#### x86 instructions 

There are Intel and AT&T syntaxes of instructions. 
* Intel syntax
```
add eax, ebx ; destination register appears first
```
* AT&T syntax for the same instruction
```
addq %ebx, %eax ; source register appears first
```
We use the Intel syntax. Please see example instructions as folows.
```
mov eax, 10	; move 10 into eax. 10 is an immediate operand. eax is a register operand
```
```
mov eax, [ecx]	; Move the 4 bytes in memory at the address contained in ECX into EAX. [ecx] is a memory operand
```
```
lea eax, [ebx+8] ; Put result of ebx+8 into eax
```
```
add eax, 5	; add 5 into eax
```
```
push eax	; push eax onto stack. esp+=4
```
```
call func	; call a function named func.
```
```
ret	; a function returns
```
```
cmp	eax, 3 ; compare if eax and 3 are the same
```
```
jne	error1 ; Not equal then jump to the code labled as error1
```
Refer to References [1] and [3] for more assembly language grammars.

## Heap and stack
We can use the data section (.data for initialized data and .bss for un-initialized data) for global variables, which are part of the executable file. Remember malloc(.) and those local variables declared within a function in C? Where are they allocated? malloc(.) allocates a chunk of memory in a special region called "heap" in the computer memory. You shall free allocated memory on the heap when the use is done. Local variables and function arguments are allocated on another special region called "stack" in the computer memory. You shall free the allocated memory on the stack too when it is done. When you write the C code, freeing the stack is done automatically for you. However, in assembly code, you may have to write code and free the stack space.

I want to discuss the stack more. The address of the stack top is saved in the register "esp". You can use "push" to push (save) data onto the stack or "pop" to pop (free) data out of the stack.
```
push	ebx ; push the value in ebx onto the stack and esp=esp-4
pop ebx ; pop the value at the stack top into ebx and esp=esp+4
```
You can see when we use push and pop, esp is automatically adjusted to point to the top of the stack. One thing that might look weird is when we push ebx onto the stack, esp decreases by 4 bytes. This is related to the computer architecture and memory layout.

You can adjust the stack with arithmetic instructions too. For example,
```
add	esp, 4 ; increase esp by 4, freeing 4 bytes from the stack
```
You can see when we operate on the stack, we just manipulate esp. As a result, we do not really erase the data with a pop. But the operation is logically equivalnent to saving data and freeing space on the stack.

The stack is often used with functions. Your code consists of a set of functions, including the main(.) function. When a function is called, a chunk of stack is allocated for the function use. This chunk of stack is called a stack frame, which has the layout below in general although some parts may not be needed for particular functions. 
```
        +------------------------------+ <-- Higher address
        | function arguments           |
        +------------------------------+
        | return address               |
        +------------------------------+
        | saved registers (e.g. ebp)   |
EBP --> +------------------------------+  
        | local variables              |
ESP --> +------------------------------+  <-- Lower address
```
Please note: the stack frame is actually created by instructions. When you read the assembly code, you see the forming of the stack frame. When you write the code, you will have to write the code creating the stack frame.

Here is a video explaining the use of stack by func.asm.

[![IMAGE ALT TEXT HERE](https://img.youtube.com/vi/oPk8boPlnKA/0.jpg)](https://youtu.be/oPk8boPlnKA)

## Code examples

#### exitProcess.asm
This is a Win32 console program that asks for a name and prints out a greeting message then exits. It needs to be linked with Windows libraries.

```
Assemble: nasm -f win exitProcess.asm
Link: golink /console exitProcess.obj msvcrt.dll kernel32.dll
```

#### func.asm
This is a Win32 console program that uses a function to compute an addition sum and prints out the result. It needs to be linked with Windows libraries.

```
Assemble: nasm -f win func.asm
Link: golink /console func.obj msvcrt.dll kernel32.dll
```

#### MessageBox.asm
This is a Win32 program that pops up a message box. It needs to be linked with Windows libraries.
```
Assemble: nasm -f win MessageBox.asm
Link: golink MessageBox.obj user32.dll kernel32.dll
```

#### helloworld.asm
This is a gcc command line program that writes "Hello, World" on one line and then exits.  It needs to be linked with standard C libraries.

```
Assemble: nasm -f win helloworld.asm
Link: gcc -m32 helloworld.obj -o helloworld.exe
```

#### helloworld-gl.asm
This is the golink version of helloworld.asm. It is a Win32 console program that writes "Hello, World" on one line and then exits.  It needs to be linked with a Windows API library.

```
; Assemble: nasm -f win helloworld-gl.asm
; Link: golink /console helloworld-gl.obj msvcrt.dll
```


#### power.asm
This is a gcc command line application to compute x^y, where x and y are integers. It needs to be linked with standard C libraries.

```
Assemble: nasm -f win power.asm
Link: gcc -m32 power.obj -o power.exe
```

## References
1. [Assembly Programming Tutorial](https://www.tutorialspoint.com/assembly_programming/index.htm)
1. nasm [doc](https://www.nasm.us/pub/nasm/releasebuilds/2.14.02/doc/)
1. Randall Hyde, [The Art of Assembly Language](https://www.amazon.com/Art-Assembly-Language-2nd/dp/1593272073), 2nd Edition, Mar 01, 2010 | ISBN 9781593272074
